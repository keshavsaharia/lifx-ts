import dgram from 'dgram'

import {
	LifxServer,
	LifxDevice,
	Packet,
	Response,
	DeviceDiscover,
	ClientLogEmitter
} from '.'

import {
	LifxNetworkInterface,
	Transmission,
	QueuedRequest,
	LifxDeviceHandler,
	DeviceGroup,
	ClientState
} from './interface'

import {
	getIPv4Interfaces,
	broadcast,
	unicast,
	createSocket
} from './network'

import {
	LIFX_PORT,
	DEFAULT_TIMEOUT,
	RATE_LIMIT
} from './constant'

import {
	DeviceTimeoutError,
	DeviceRequestError,
	ClientDisconnectError
} from './error'

/**
 * @class 	LifxClient
 * @desc 	LAN client for communicating with LIFX smart bulbs and devices over the local network,
 * 			without needing to talk to any external servers.
 */
export default class LifxClient {
	// Unique ID
	private id: number

	// UI/API/admin server
	private server?: LifxServer

	// Devices and mapping
	private devices: Array<LifxDevice>
	private device: { [mac: string]: LifxDevice }

	// Sequence number for mapping UDP requests to responses
	private sequence: number
	private request: { [sequence: number]: Packet<any> }

	// Request queueing and dequeueing timer
	private queue: Array<QueuedRequest>
	private dequeuer: NodeJS.Timer

	// Network interface and socket
	private network: Array<LifxNetworkInterface>
	private udp: dgram.Socket
	private port: number
	private alive: boolean
	private monitoring?: NodeJS.Timer

	// Event handler
	private handler: { [event: string]: Array<LifxDeviceHandler> }

	// Logging configuration
	log: ClientLogEmitter

	/**
	 * @constructor
	 * @desc 	Initializes a client instance for communicating with Lifx devices.
	 * 			You can call .hasNetwork() to check if the client has an available
	 * 			IPv4 network interface to send packets on.
	 */
	constructor() {
		// Unique client ID
		this.id = Math.floor(Math.random() * 0xffffffff)
		this.log = new ClientLogEmitter(this)

		// Sequenced request cache
		this.request = {}
		this.sequence = 0
		this.queue = []

		// Devices and associated callback function map
		this.devices = []
		this.device = {}
		this.handler = {}

		// Initialize network interfaces from OS
		this.network = getIPv4Interfaces()
		this.alive = false
	}

	/**
	 * @func 	start
	 * @desc 	Starts the client by initializing the UDP socket and binding incoming
	 * 			socket messages to this client instance.
	 */
	async start(port?: number): Promise<LifxClient> {
		if (this.udp && this.alive)
			return this

		// If the socket is successfully created, set the "alive" flag to true
		this.log.startClient()
		this.port = port || LIFX_PORT
		this.udp = await createSocket(this.port, this.receivePacket.bind(this))
		this.alive = true
		this.log.startClient(true)

		// Start interactive logging
		this.log.interactive()

		// Listen to shutdown signals and close the socket
		process.on('SIGTERM', () => this.stop())
        process.on('SIGINT', () => this.stop())

		return this
	}

	/**
	 * @func 	startServer
	 * @desc 	Start the management/API HTTP server
	 */
	async startServer() {
		if (! this.server) {
			this.server = new LifxServer(this)
			await this.server.start()
		}
		return this
	}

	/**
	 * @func 	stop
	 * @desc 	Stops the UDP socket and any periodic monitors.
	 * @returns {Promise<boolean>} true if shutdown process succeeded or in progress
	 */
	async stop(): Promise<boolean> {
		// Ensure function is only called once
		if (! this.udp || ! this.alive)
			return true
		this.alive = false

		this.log.stopClient()
		if (this.server)
			try {
				await this.server.stop()
			}
			catch (error) {
				console.log('server', error)
			}

		// Clear queue and dequeuing process
		this.queue = []
		if (this.dequeuer)
			clearInterval(this.dequeuer)

		// Stop monitoring intervals
		this.stopMonitoring()
		await Promise.all(this.devices.map((device) => device.stopMonitoring()))

		// Close and/or unref the UDP socket
		const stopped = await new Promise((resolve: (stopped: boolean) => any) => {
			try {
				this.udp.close(() => {
					this.udp.unref()
					resolve(true)
				})
			}
			catch (error) {
				try {
					this.udp.unref()
					resolve(true)
				}
				catch (e) {
					resolve(false)
				}
			}
		})

		// Close process if any resources left hanging
		if (stopped)
			process.exit(0)
		return stopped
	}

	/**
	 * @func 	receivePacket
	 * @desc 	Internal handler for parsing incoming UDP packets and passing the
	 * 			response payload to the original request packet.
	 */
	private receivePacket(buffer: Buffer, info: dgram.RemoteInfo) {
		// Ignore packets generated by a network interface associated with this client
		if (this.network.find((networkInfo) => (networkInfo.address == info.address)))
			return

		// Parse the response and search for an associated cached request packet
		const response = new Response(buffer, info)
		const request = this.getPacket(response)
		if (request)
			request.emitResponse(response)
	}

	/**
	 * @func 	discover
	 * @desc 	Broadcast a discovery packet and initialize a connection to
	 * 			devices that respond.
	 */
	async discover() {
		await this.start()
		const discovery = new DeviceDiscover()

		// Create new LifxDevice instances from each unique IP that responds to the
		// discovery packet
		discovery.onResponse((response, payload) => {
			if (! this.hasDevice(response))
				this.addDevice(new LifxDevice(this, response.ip, response.mac, payload.port))
		})

		// Broadcast the discover packet on all available network interfaces
		await Promise.all(this.network.map((network) =>
			this.broadcast(discovery, network)))

		return this
	}

	hasDevice(response: Response | string) {
		return this.device[(response instanceof Response) ? response.mac : response] != null
	}

	getDevices() {
		return this.devices
	}

	getDevice(mac: string): LifxDevice {
		return this.device[mac]
	}

	getGroups(): Array<DeviceGroup> {
		const groups: Array<DeviceGroup> = []
		this.devices.forEach((device) => {
			if (device.group && ! groups.find((g) => (g.id === device.group!.id)))
				groups.push(device.group)
		})
		return groups
	}

	getLocations(): Array<DeviceGroup> {
		const locations: Array<DeviceGroup> = []
		this.devices.forEach((device) => {
			if (device.location && ! locations.find((l) => (l.id === device.location!.id)))
				locations.push({
					...device.location,
					location: true
				})
		})
		return locations
	}

	getGroup(ref: DeviceGroup | string): Array<LifxDevice> {
		return this.devices.filter((device) => device.inGroup(ref))
	}

	getLocation(ref: DeviceGroup | string): Array<LifxDevice> {
		return this.devices.filter((device) => device.inLocation(ref))
	}

	getState(): ClientState {
		return {
			id: this.id,
			alive: this.alive,
			queue: this.queue.length,
			group: this.getGroups(),
			location: this.getLocations(),
			device: this.devices.map((device) => device.state)
		}
	}

	addDevice(device: LifxDevice): LifxDevice {
		this.devices.push(device)
		this.device[device.getMacAddress()] = device
		this.emit('connect', device)
		return device
	}

	removeDevice(device: LifxDevice): LifxDevice | null {
		return this.removeDeviceIndex(
			this.devices.findIndex((d) => (d == device)))
	}

	private removeDeviceIndex(index: number) {
		if (index < 0 || index >= this.devices.length)
			return null

		const device = this.devices.splice(index, 1)[0]
		delete this.device[device.getMacAddress()]
		device.stopMonitoring()
		this.emit('disconnect', device)
		return device
	}

	monitor(interval: number) {
		this.stopMonitoring()
		this.monitoring = setInterval(async () => {
			try {
				await this.ping(interval)
				await this.discover()
			}
			catch (error) {
				// TODO: client monitoring error log
			}
		}, interval)
	}

	stopMonitoring() {
		if (this.monitoring)
			clearInterval(this.monitoring)
	}

	async ping(timeout?: number) {
		if (! this.alive)
			return

		// Get a list of all device MAC addresses that responded to the ping
		// TODO: switch to sequential ping of devices to prevent overloading queue
		const responses = await Promise.all(this.devices.map((device) => device.ping(timeout)))
		const pong = new Set<string>(responses.filter((r) => (r != null)) as Array<string>)

		// Remove all devices that did not respond
		this.devices.forEach((device) => {
			if (! pong.has(device.getMacAddress()))
				this.removeDevice(device)
		})
	}

	on(event: Array<string> | string, handler: LifxDeviceHandler) {
		if (Array.isArray(event)) {
			event.forEach((e) => this.on(e, handler))
			return this
		}

		if (! this.handler[event])
			this.handler[event] = []
		this.handler[event].push(handler)
		return this
	}

	emit(event: string, device: LifxDevice) {
		if (this.handler[event])
			this.handler[event].forEach((handler) => {
				try {
					handler(device)
				}
				catch (e) {
					// TODO: client error log
				}
			})
	}

	async onConnect(handler: LifxDeviceHandler) {
		return this.on('connect', handler)
	}

	async onLoad(handler: LifxDeviceHandler) {
		return this.on('load', handler)
	}

	async onChange(handler: LifxDeviceHandler) {
		return this.on('change', handler)
	}

	async onDisconnect(handler: LifxDeviceHandler) {
		return this.on('disconnect', handler)
	}

	async send<R>(packet: Packet<R>, device: LifxDevice): Promise<Transmission> {
		if (! this.alive)
			await this.start()

		// Create a Transmission object and unicast to the device without processing
		// any response that is sent back from the device or waiting for a reply
		const transmission = this.build(packet, device, true)
		this.unicast(transmission, device)
		return transmission
	}

	async get<Result>(packet: Packet<Result>, device: LifxDevice, timeout?: number): Promise<Result> {
		if (! this.alive)
			await this.start()

		return new Promise(async (resolve: (payload: Result) => any, reject) => {
			const transmission = this.build(packet, device)

			const deviceTimeout = setTimeout(() => {
				this.clearPacket(packet, transmission)
				reject({
					...DeviceTimeoutError,
					label: device.getName(),
					ip: device.getIP(),
					mac: device.getMacAddress(),
					packet: packet.getName()
				})
			}, timeout || DEFAULT_TIMEOUT)

			packet.onResponse((response, payload) => {
				clearTimeout(deviceTimeout)

				if (device.didRespond(response)) {
					this.clearPacket(packet, response)
					resolve(payload)
				}
				else reject(DeviceRequestError)
			})

			await this.unicast(transmission, device)
		})

	}

	//
	// UDP SOCKET COMMUNICATION
	//
	//

	/**
	 * @func 	broadcast
	 * @desc	Broadcast the given packet to all devices reachable by the given network interace.
	 * @param 	{Packet<R>}
	 */
	private async broadcast<R>(packet: Packet<R>, network: LifxNetworkInterface) {
		if (! this.alive)
			throw ClientDisconnectError

		const transmission = this.build(packet)
		return broadcast(this.udp, transmission.buffer, network.broadcast)
	}

	/**
	 * @func 	unicast
	 * @desc	Send the given Transmission to the device by unicast.
	 */
	private async unicast(transmission: Transmission, device: LifxDevice) {
		if (! this.alive)
			throw ClientDisconnectError

		if (device.canSend())
			return unicast(this.udp, transmission.buffer, device.getIP(), device.getPort())
		else
			return this.enqueue(transmission, device)
	}

	/**
	 * @func 	enqueue
	 * @desc	Add the given transmission and target device to the queue, and
	 * 			periodically check if the device can be sent another packet.
	 */
	private async enqueue(transmission: Transmission, device: LifxDevice) {
		// Start the dequeue timer if not yet started
		if (! this.dequeuer)
			this.dequeuer = setInterval(this.dequeue.bind(this), RATE_LIMIT)

		return new Promise((resolve: (bytes: number) => any, reject) => {
			this.queue.push({
				transmission,
				device,
				resolve,
				reject
			})
		})
	}

	/**
	 * @func 	dequeue
	 * @desc 	Remove queued requests that can now be sent.
	 * @see 	enqueue, this.daemon
	 */
	private async dequeue() {
		// Empty queue
		if (! this.alive || this.queue.length == 0)
			return

		// Find enqueued messages that can be sent
		const send: Array<QueuedRequest> = []
		for (let i = 0 ; i < this.queue.length ; i++) {
			const enqueued = this.queue[i]

			if (enqueued.device.canSend()) {
				send.push(enqueued)
				this.queue.splice(i, 1)
				i--
			}
		}

		// Send all dequeued messages
		if (send.length > 0)
			return Promise.all(send.map((enqueued) =>
					unicast(this.udp,
							enqueued.transmission.buffer,
							enqueued.device.getIP(),
							enqueued.device.getPort())
						.then((bytes) => {
							enqueued.resolve(bytes)
						})
						.catch((error) => {
							// TODO: client error log, retry
							enqueued.reject(error)
							return 0
						})))
	}

	//
	// PACKET CACHING
	//

	/**
	 * @func 	build
	 * @desc 	Creates a Transmission typed object with a protocol buffer for sending,
	 * 			and caches the packet for handling response data if a response is expected.
	 * @return 	{Transmission} object with compiled data for sending
	 */
	private build(packet: Packet<any>, device?: LifxDevice, ignoreResponse?: boolean): Transmission {
		const transmission = packet.build(this, device)
		if (! ignoreResponse && packet.expectsResponse())
			this.cachePacket(packet, transmission)
		return transmission
	}

	/**
	 * @func 	getPacket
	 * @desc 	Get the packet associated with the given transmission or response instance.
	 * @return 	{Packet<any>} associated packet
	 */
	private getPacket(transmission: Transmission | Response): Packet<any> | undefined {
		return this.request[transmission.sequence]
	}

	/**
	 * @func 	cachePacket
	 * @desc 	Set the packet associated with the given transmission or response instance's sequence number.
	 * @return 	{LifxClient} this
	 */
	private cachePacket(packet: Packet<any>, transmission: Transmission) {
		this.request[transmission.sequence] = packet
		return this
	}

	/**
	 * @func 	clearPacket
	 * @desc 	Remove the packet associated with the given transmission or response instance's sequence number.
	 * @return 	{LifxClient} this
	 */
	private clearPacket(packet: Packet<any>, p: Response | Transmission): LifxClient {
		if (this.request[p.sequence] == packet)
			delete this.request[p.sequence]
		return this
	}

	/**
	 * @func 	nextSequence
	 * @desc 	Replies from a device will copy the triplet of (source, sequence, target)
	 * 			from the request packet. The `sequence` UInt8 is used to determine which request
	 * 			resulted in which reply. Sequence increments for each message sent, and then wraps
	 * 			to 0 after it reaches 255.
	 * @return 	{number} - next sequence number
	 */
	nextSequence(): number {
		return this.sequence = (this.sequence + 1) % 255
	}

	/**
	 * @func 	getId
	 * @desc 	Get the unique ID of this client.
	 * @return 	{number} - random ID
	 */
	getId(): number {
		return this.id
	}

	hasNetwork() {
		return this.network.length > 0
	}

	isRunning(): boolean {
		return this.alive
	}

	getSocket() {
		return this.udp
	}

	getNetwork() {
		return this.network
	}

}
