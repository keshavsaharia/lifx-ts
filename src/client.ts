import dgram from 'dgram'

import {
	Packet,
	LifxDevice,
	Response,
	DeviceDiscover
} from '.'

import {
	LifxNetworkInterface,
	Transmission,
	LifxDeviceHandler,
	DeviceGroup,
	ClientState
} from './interface'

import {
	getIPv4Interfaces,
	broadcast,
	unicast,
	createSocket
} from './network'

import {
	LIFX_PORT,
	DEFAULT_TIMEOUT,
	RATE_LIMIT
} from './constant'

import {
	DeviceTimeoutError,
	DeviceRequestError
} from './error'

/**
 * @class 	LifxClient
 * @desc 	LAN client for communicating with LIFX smart bulbs and devices over the local network,
 * 			without needing to talk to any external servers.
 */
export default class LifxClient {
	// Unique ID
	private id: number

	// Devices and mapping
	private devices: Array<LifxDevice>
	private device: { [mac: string]: LifxDevice }

	// Sequence number for mapping UDP requests to responses
	private sequence: number
	private request: { [sequence: number]: Packet<any> }
	private queue: Array<{
		transmission: Transmission
		device: LifxDevice
		resolve?: (bytes: number) => any
		reject?: (error: any) => any
	}>
	private daemon: NodeJS.Timer

	// Network interface and socket
	private network: Array<LifxNetworkInterface>
	private udp: dgram.Socket
	private port: number
	private alive: boolean
	private monitoring?: NodeJS.Timer

	// Event handler
	private handler: { [event: string]: Array<LifxDeviceHandler> }

	/**
	 * @constructor
	 */
	constructor() {
		// Unique client ID
		this.id = Math.floor(Math.random() * 0xffffffff)

		// Sequenced request cache
		this.request = {}
		this.sequence = 0
		this.queue = []

		// Devices and associated callback function map
		this.devices = []
		this.device = {}
		this.handler = {}

		// Initialize network interfaces from OS
		this.network = getIPv4Interfaces()
		this.alive = false
	}

	/**
	 * @func 	start
	 * @desc 	Starts the client by initializing the UDP socket and binding incoming
	 * 			socket messages to this client instance.
	 */
	async start(port?: number): Promise<LifxClient> {
		if (this.udp && this.alive)
			return this

		// If the socket is successfully created, set the "alive" flag to true
		this.port = port || LIFX_PORT
		this.udp = await createSocket(this.port, this.receivePacket.bind(this))
		this.daemon = setInterval(this.dequeue.bind(this), RATE_LIMIT)
		this.alive = true

		// Listen to shutdown signals and close the socket
		process.on('SIGTERM', () => this.stop())
        process.on('SIGINT', () => this.stop())

		return this
	}

	async stop(): Promise<boolean> {
		if (! this.udp)
			return true

		// Clear queue and rate limit interval
		this.queue = []
		if (this.daemon)
			clearInterval(this.daemon)

		// Stop monitoring intervals
		this.stopMonitoring()
		await Promise.all(this.devices.map((device) => device.stopMonitoring()))

		if (this.udp && ! this.alive) {
			this.udp.unref()
			return true
		}

		return new Promise((resolve: (stopped: boolean) => any) => {
			try {
				this.udp.close(() => {
					this.udp.unref()
					this.alive = false
					resolve(true)
				})
			}
			catch (error) {
				this.alive = false
				resolve(false)
			}
		})
	}

	/**
	 * @func 	receivePacket
	 * @desc 	Internal handler for parsing incoming UDP packets and passing the
	 * 			response payload to the original request packet.
	 */
	private receivePacket(buffer: Buffer, info: dgram.RemoteInfo) {
		// Ignore packets generated by a network interface associated with this client
		if (this.network.find((networkInfo) => (networkInfo.address == info.address)))
			return

		// Parse the response and search for an associated cached request packet
		const response = new Response(buffer, info)
		const request = this.getPacket(response)
		if (request)
			request.emitResponse(response)
	}

	/**
	 * @func 	discover
	 * @desc 	Broadcast a discovery packet and initialize a connection to
	 * 			devices that respond.
	 */
	async discover() {
		await this.start()
		const discovery = new DeviceDiscover()

		// Create new LifxDevice instances from each unique IP that responds to the
		// discovery packet
		discovery.onResponse((response, payload) => {
			if (! this.hasDevice(response))
				this.addDevice(new LifxDevice(this, response.ip, response.mac, payload.port))
		})

		// Broadcast the discover packet on all available network interfaces
		await Promise.all(this.network.map((network) =>
			this.broadcast(discovery, network)))

		return this
	}

	hasDevice(response: Response | string) {
		return this.device[(response instanceof Response) ? response.mac : response] != null
	}

	getDevices() {
		return this.devices
	}

	getGroups(): Array<DeviceGroup> {
		return this.devices.map((device) => device.group)
			.filter((group) => group != null) as Array<DeviceGroup>
	}

	getLocations(): Array<DeviceGroup> {
		return this.devices.map((device) => device.location)
			.filter((group) => group != null) as Array<DeviceGroup>
	}

	getGroup(ref: DeviceGroup | string): Array<LifxDevice> {
		return this.devices.filter((device) => device.inGroup(ref))
	}

	getLocation(ref: DeviceGroup | string): Array<LifxDevice> {
		return this.devices.filter((device) => device.inLocation(ref))
	}

	getState(): ClientState {
		return {
			id: this.id,
			alive: this.alive,
			queue: this.queue.length,
			device: this.devices.map((device) => device.getState())
		}
	}

	addDevice(device: LifxDevice): LifxDevice {
		this.devices.push(device)
		this.device[device.getMacAddress()] = device
		this.emit('connect', device)
		return device
	}

	removeDevice(device: LifxDevice): LifxDevice | null {
		return this.removeDeviceIndex(
			this.devices.findIndex((d) => (d == device)))
	}

	private removeDeviceIndex(index: number) {
		if (index < 0 || index >= this.devices.length)
			return null

		const device = this.devices.splice(index, 1)[0]
		delete this.device[device.getMacAddress()]
		device.stopMonitoring()
		this.emit('disconnect', device)
		return device
	}

	monitor(interval: number) {
		this.stopMonitoring()
		this.monitoring = setInterval(async () => {
			await this.ping(interval)
			await this.discover()
		}, interval)
	}

	stopMonitoring() {
		if (this.monitoring)
			clearInterval(this.monitoring)
	}

	async ping(timeout?: number) {
		if (! this.alive)
			return

		const responses = await Promise.all(this.devices.map((device) => device.ping(timeout)))
		const pongs = new Set<string>()
		responses.forEach((response) => {
			if (response != null)
				pongs.add(response)
		})

		this.devices.forEach((device) => {
			if (! pongs.has(device.getMacAddress()))
				this.removeDevice(device)
		})
	}

	on(event: Array<string> | string, handler: LifxDeviceHandler) {
		if (Array.isArray(event)) {
			event.forEach((e) => this.on(e, handler))
			return this
		}

		if (! this.handler[event])
			this.handler[event] = []
		this.handler[event].push(handler)
		return this
	}

	emit<Result>(event: string, device: LifxDevice) {
		if (this.handler[event])
			this.handler[event].forEach((handler) => {
				try {
					handler(device)
				}
				catch (e) {
					console.log('client handler for ' + event, e)
				}
			})
	}

	async onConnect(handler: LifxDeviceHandler) {
		return this.on('connect', handler)
	}

	async onLoad(handler: LifxDeviceHandler) {
		return this.on('load', handler)
	}

	async onChange(handler: LifxDeviceHandler) {
		return this.on('change', handler)
	}

	async onDisconnect(handler: LifxDeviceHandler) {
		return this.on('disconnect', handler)
	}

	async send<R>(packet: Packet<R>, device: LifxDevice): Promise<Transmission> {
		if (! this.alive)
			await this.start()

		// Create a Transmission object and unicast to the device without processing
		// any response that is sent back from the device or waiting for a reply
		const transmission = this.build(packet, device, true)
		this.unicast(transmission, device)
		return transmission
	}

	async get<Result>(packet: Packet<Result>, device: LifxDevice, timeout?: number): Promise<Result> {
		if (! this.alive)
			await this.start()

		return new Promise(async (resolve: (payload: Result) => any, reject) => {
			const transmission = this.build(packet, device)

			const deviceTimeout = setTimeout(() => {
				this.clearPacket(packet, transmission)
				reject({
					...DeviceTimeoutError,
					label: device.getName(),
					ip: device.getIP(),
					mac: device.getMacAddress(),
					packet: packet.getName()
				})
			}, timeout || DEFAULT_TIMEOUT)

			packet.onResponse((response, payload) => {
				clearTimeout(deviceTimeout)

				if (device.didRespond(response)) {
					this.clearPacket(packet, response)
					resolve(payload)
				}
				else reject(DeviceRequestError)
			})

			await this.unicast(transmission, device)
		})

	}

	//
	// UDP SOCKET COMMUNICATION
	//
	//

	/**
	 * @func 	broadcast
	 * @desc	Broadcast the given packet to all devices reachable by the given network interace.
	 * @param 	{Packet<R>}
	 */
	private async broadcast<R>(packet: Packet<R>, network: LifxNetworkInterface) {
		const transmission = this.build(packet)
		return broadcast(this.udp, transmission.buffer, network.broadcast)
	}

	/**
	 * @func 	unicast
	 * @desc	Send the given Transmission to the device by unicast.
	 */
	private async unicast(transmission: Transmission, device: LifxDevice) {
		if (device.canSend())
			return unicast(this.udp, transmission.buffer, device.getIP(), device.getPort())
		else return new Promise((resolve: (bytes: number) => any, reject) => {
			this.queue.push({
				transmission,
				device,
				resolve,
				reject
			})
		})
	}

	/**
	 * @desc 	Remove queued requests that can be sent by unicast.
	 */
	private async dequeue() {
		// Empty queue
		if (this.queue.length == 0)
			return

		// Find enqueued messages that can be sent
		const send = this.queue.filter((enqueued) => enqueued.device.canSend())
		if (send.length > 0) {
			// Remove the messages from the queue
			send.forEach((enqueued) => {
				const index = this.queue.findIndex((e) => (e == enqueued))
				if (index >= 0)
					this.queue.splice(index, 1)
			})

			// Send all dequeued messages
			return Promise.all(send.map((enqueued) =>
					unicast(this.udp,
							enqueued.transmission.buffer,
							enqueued.device.getIP(),
							enqueued.device.getPort()).then((bytes) => {
								if (enqueued.resolve)
									enqueued.resolve(bytes)
							})
							.catch((error) => {
								console.log('queue error', error)
								if (enqueued.reject)
									enqueued.reject(error)
							})))
		}
	}

	//
	// PACKET CACHING
	//

	/**
	 * @func 	build
	 * @desc 	Creates a Transmission typed object with a protocol buffer for sending,
	 * 			and caches the packet for handling response data if a response is expected.
	 * @return 	{Transmission} object with compiled data for sending
	 */
	private build(packet: Packet<any>, device?: LifxDevice, ignoreResponse?: boolean): Transmission {
		const transmission = packet.build(this, device)
		if (! ignoreResponse && packet.expectsResponse())
			this.cachePacket(packet, transmission)
		return transmission
	}

	/**
	 * @func 	getPacket
	 * @desc 	Get the packet associated with the given transmission or response instance.
	 * @return 	{Packet<any>} associated packet
	 */
	private getPacket(transmission: Transmission | Response): Packet<any> | undefined {
		return this.request[transmission.sequence]
	}

	/**
	 * @func 	cachePacket
	 * @desc 	Set the packet associated with the given transmission or response instance's sequence number.
	 * @return 	{LifxClient} this
	 */
	private cachePacket(packet: Packet<any>, transmission: Transmission) {
		this.request[transmission.sequence] = packet
		return this
	}

	/**
	 * @func 	clearPacket
	 * @desc 	Remove the packet associated with the given transmission or response instance's sequence number.
	 * @return 	{LifxClient} this
	 */
	private clearPacket(packet: Packet<any>, p: Response | Transmission): LifxClient {
		if (this.request[p.sequence] == packet)
			delete this.request[p.sequence]
		return this
	}

	/**
	 * @func 	nextSequence
	 * @desc 	Replies from a device will copy the triplet of (source, sequence, target)
	 * 			from the request packet. The `sequence` UInt8 is used to determine which request
	 * 			resulted in which reply. Sequence increments for each message sent, and then wraps
	 * 			to 0 after it reaches 255.
	 * @return 	{number} - next sequence number
	 */
	nextSequence(): number {
		return this.sequence = (this.sequence + 1) % 255
	}

	/**
	 * @func 	getId
	 * @desc 	Get the unique ID of this client.
	 * @return 	{number} - random ID
	 */
	getId() {
		return this.id
	}

	isRunning() {
		return this.alive
	}

}
